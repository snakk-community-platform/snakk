@page "/auth/profile"
@model Snakk.Web.Pages.Auth.ProfileModel
@{
    ViewData["Title"] = "Profile Settings";
}

<div class="max-w-2xl mx-auto">
    <!-- Breadcrumb -->
    <nav class="breadcrumb">
        <a href="/">Home</a>
        <span class="breadcrumb-separator">/</span>
        <span class="breadcrumb-current">Profile Settings</span>
    </nav>

    <div class="page-header">
        <h1>Profile Settings</h1>
        <p>Manage your account and preferences</p>
    </div>

    @if (Model.ErrorMessage != null)
    {
        <div class="alert alert-error mb-6">
            <span>@Model.ErrorMessage</span>
        </div>
    }

    @if (Model.SuccessMessage != null)
    {
        <div class="alert alert-success mb-6">
            <span>@Model.SuccessMessage</span>
        </div>
    }

    <!-- Avatar Section -->
    <div class="clean-card mb-6">
        <h2 class="text-lg font-semibold mb-4">Avatar</h2>

        <div class="flex items-start gap-6">
            <!-- Current Avatar -->
            <div class="flex flex-col items-center gap-3">
                <div class="avatar avatar-xl" id="current-avatar">
                    <img src="@Model.ApiBaseUrl/avatars/@Model.UserId"
                         alt="Your avatar"
                         id="avatar-preview" />
                </div>
                <span class="text-sm text-muted">Current avatar</span>
            </div>

            <!-- Upload Form -->
            <div class="flex-1">
                <p class="text-sm text-muted mb-4">
                    Upload a custom avatar or use the auto-generated one based on your user ID.
                    Supported formats: JPEG, PNG, GIF, WebP. Maximum size: 2MB.
                </p>

                <form id="avatar-upload-form" class="space-y-4">
                    <div class="form-control">
                        <input type="file"
                               id="avatar-file"
                               name="avatar"
                               accept="image/jpeg,image/png,image/gif,image/webp"
                               class="file-input file-input-bordered w-full max-w-xs" />
                    </div>

                    <div class="flex gap-2">
                        <button type="submit" class="btn btn-primary btn-sm" id="upload-btn">
                            Upload Avatar
                        </button>
                        <button type="button" class="btn btn-ghost btn-sm" id="delete-avatar-btn">
                            Use Generated Avatar
                        </button>
                    </div>
                </form>

                <div id="upload-status" class="mt-3 text-sm hidden"></div>
            </div>
        </div>
    </div>

    <!-- Display Name Section -->
    <div class="clean-card mb-6">
        <h2 class="text-lg font-semibold mb-4">Display Name</h2>

        <form id="display-name-form" asp-page-handler="UpdateDisplayName" class="space-y-4">
            <div class="form-control">
                <input type="text"
                       name="displayName"
                       value=""
                       class="input input-bordered w-full max-w-xs"
                       required
                       placeholder="Your display name" />
                <label class="label">
                    <span class="label-text-alt text-muted">This is how others will see you in discussions</span>
                </label>
            </div>

            <button type="submit" class="btn btn-primary btn-sm">
                Update Display Name
            </button>
        </form>
    </div>

    <!-- Preferences Section -->
    <div class="clean-card mb-6">
        <h2 class="text-lg font-semibold mb-4">Preferences</h2>

        <div class="space-y-4">
            <div class="form-control">
                <label class="label cursor-pointer justify-start gap-4">
                    <input type="checkbox"
                           name="preferEndlessScroll"
                           class="toggle toggle-primary" />
                    <span class="label-text">
                        <span class="font-medium">Endless scroll</span>
                        <span class="block text-sm text-muted">
                            Automatically load more content as you scroll. Disable to use traditional pagination buttons.
                        </span>
                    </span>
                </label>
            </div>
        </div>
    </div>

    <!-- Account Info Section -->
    <div class="clean-card">
        <h2 class="text-lg font-semibold mb-4">Account Information</h2>

        <dl class="space-y-3">
            <div class="flex items-center gap-2" id="email-row">
                <dt class="text-muted w-24">Email:</dt>
                <dd class="flex items-center gap-2" id="profile-email-container">
                    <span id="profile-email"></span>
                    <span id="profile-email-badge" class="badge badge-sm"></span>
                </dd>
            </div>

            <div class="flex items-center gap-2" id="oauth-row" style="display: none;">
                <dt class="text-muted w-24">Sign in:</dt>
                <dd class="capitalize" id="profile-oauth"></dd>
            </div>

            <div class="flex items-center gap-2">
                <dt class="text-muted w-24">User ID:</dt>
                <dd class="font-mono text-sm" id="profile-userid"></dd>
            </div>
        </dl>
    </div>
</div>

<script>
@* INLINE REASON: Page-specific profile settings functionality including client-side authentication check,
   profile data loading, avatar upload, and form submissions. Not reused elsewhere. *@

(function() {
    const apiBaseUrl = window.apiBaseUrl || 'https://localhost:7291';
    let userId = null;
    let userData = null;

    // Client-side authentication check and profile data loading
    async function initProfileSettings() {
        // Check authentication
        if (!window.snakkAuth || !window.snakkAuth.isAuthenticated()) {
            console.log('[Profile Settings] Not authenticated, redirecting to login');
            window.location.href = '/auth/login?returnUrl=/auth/profile';
            return;
        }

        // Load profile data from API
        try {
            const response = await fetch(`${apiBaseUrl}/auth/me`, {
                credentials: 'include'
            });

            if (!response.ok) {
                throw new Error('Failed to load profile');
            }

            userData = await response.json();
            userId = userData.publicId;

            console.log('[Profile Settings] Loaded profile data:', userData);
            populateProfileForm(userData);
        } catch (error) {
            console.error('[Profile Settings] Failed to load profile:', error);
            window.location.href = '/auth/login?returnUrl=/auth/profile';
        }
    }

    function populateProfileForm(data) {
        // Update avatar
        const avatarImg = document.getElementById('avatar-preview');
        if (avatarImg) {
            avatarImg.src = `${apiBaseUrl}/avatars/${data.publicId}`;
        }

        // Update display name input
        const displayNameInput = document.querySelector('input[name="displayName"]');
        if (displayNameInput) {
            displayNameInput.value = data.displayName || '';
        }

        // Update preferences checkbox
        const scrollCheckbox = document.querySelector('input[name="preferEndlessScroll"]');
        if (scrollCheckbox) {
            scrollCheckbox.checked = data.preferEndlessScroll !== false;
        }

        // Update account info section
        if (data.email) {
            const emailEl = document.getElementById('profile-email');
            const emailBadge = document.getElementById('profile-email-badge');
            const emailRow = document.getElementById('email-row');

            if (emailEl) emailEl.textContent = data.email;
            if (emailBadge) {
                emailBadge.textContent = data.emailVerified ? 'Verified' : 'Not verified';
                emailBadge.className = data.emailVerified
                    ? 'badge badge-success badge-sm'
                    : 'badge badge-warning badge-sm';
            }
            if (emailRow) emailRow.style.display = '';
        }

        if (data.oAuthProvider) {
            const oauthEl = document.getElementById('profile-oauth');
            const oauthRow = document.getElementById('oauth-row');

            if (oauthEl) oauthEl.textContent = data.oAuthProvider;
            if (oauthRow) oauthRow.style.display = '';
        }

        const userIdEl = document.getElementById('profile-userid');
        if (userIdEl) {
            userIdEl.textContent = data.publicId;
        }
    }

    function showStatus(message, isError = false) {
        const statusDiv = document.getElementById('upload-status');
        if (!statusDiv) return;
        statusDiv.textContent = message;
        statusDiv.className = 'mt-3 text-sm ' + (isError ? 'text-error' : 'text-success');
        statusDiv.classList.remove('hidden');
    }

    function showMessage(message, isError = false) {
        // Remove existing messages
        const existingAlerts = document.querySelectorAll('.profile-alert-message');
        existingAlerts.forEach(el => el.remove());

        // Create new message
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert ${isError ? 'alert-error' : 'alert-success'} mb-6 profile-alert-message`;
        alertDiv.innerHTML = `<span>${message}</span>`;

        // Insert after page header
        const pageHeader = document.querySelector('.page-header');
        if (pageHeader) {
            pageHeader.insertAdjacentElement('afterend', alertDiv);
            // Scroll to message
            alertDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        // Auto-remove after 5 seconds
        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }

    function refreshAvatar() {
        const avatarPreview = document.getElementById('avatar-preview');
        if (!avatarPreview || !userId) return;
        // Add cache-busting query param
        const timestamp = new Date().getTime();
        avatarPreview.src = `${apiBaseUrl}/avatars/${userId}?t=${timestamp}`;
    }

    function handleFileChange(e) {
        const avatarPreview = document.getElementById('avatar-preview');
        const fileInput = document.getElementById('avatar-file');
        if (!avatarPreview || !fileInput) return;

        const file = e.target.files[0];
        if (file) {
            // Validate file size
            if (file.size > 2 * 1024 * 1024) {
                showStatus('File is too large. Maximum size is 2MB.', true);
                fileInput.value = '';
                return;
            }

            // Preview
            const reader = new FileReader();
            reader.onload = function(e) {
                avatarPreview.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }
    }

    async function handleAvatarUploadSubmit(e) {
        e.preventDefault();

        const fileInput = document.getElementById('avatar-file');
        const uploadBtn = document.getElementById('upload-btn');
        if (!fileInput || !uploadBtn) return;

        const file = fileInput.files[0];
        if (!file) {
            showStatus('Please select a file first.', true);
            return;
        }

        uploadBtn.disabled = true;
        uploadBtn.textContent = 'Uploading...';

        try {
            const formData = new FormData();
            formData.append('avatar', file);

            const response = await fetch(`${apiBaseUrl}/avatars/upload`, {
                method: 'POST',
                body: formData,
                credentials: 'include'
            });

            const result = await response.json();

            if (response.ok) {
                showStatus('Avatar uploaded successfully!');
                refreshAvatar();
                fileInput.value = '';
            } else {
                showStatus(result.error || 'Failed to upload avatar.', true);
                refreshAvatar(); // Revert preview
            }
        } catch (error) {
            showStatus('Network error. Please try again.', true);
            refreshAvatar(); // Revert preview
        } finally {
            uploadBtn.disabled = false;
            uploadBtn.textContent = 'Upload Avatar';
        }
    }

    async function handleDeleteClick() {
        if (!confirm('Revert to the auto-generated avatar?')) {
            return;
        }

        const deleteBtn = document.getElementById('delete-avatar-btn');
        if (!deleteBtn) return;

        deleteBtn.disabled = true;
        deleteBtn.textContent = 'Reverting...';

        try {
            const response = await fetch(`${apiBaseUrl}/avatars`, {
                method: 'DELETE',
                credentials: 'include'
            });

            if (response.ok) {
                showStatus('Now using generated avatar.');
                refreshAvatar();
            } else {
                const result = await response.json();
                showStatus(result.error || 'Failed to delete avatar.', true);
            }
        } catch (error) {
            showStatus('Network error. Please try again.', true);
        } finally {
            deleteBtn.disabled = false;
            deleteBtn.textContent = 'Use Generated Avatar';
        }
    }

    async function handleDisplayNameUpdate(e) {
        e.preventDefault();

        const form = e.target;
        const displayNameInput = form.querySelector('input[name="displayName"]');
        const displayName = displayNameInput?.value?.trim();

        if (!displayName) {
            showMessage('Display name cannot be empty', true);
            return;
        }

        const submitBtn = form.querySelector('button[type="submit"]');
        if (submitBtn) {
            submitBtn.disabled = true;
            submitBtn.textContent = 'Updating...';
        }

        try {
            const response = await fetch(`${apiBaseUrl}/auth/update-profile`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({ displayName })
            });

            if (response.ok) {
                showMessage('Display name updated successfully');
            } else {
                showMessage('Failed to update display name', true);
            }
        } catch (error) {
            console.error('[Profile Settings] Update display name error:', error);
            showMessage('Network error. Please try again.', true);
        } finally {
            if (submitBtn) {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Update Display Name';
            }
        }
    }

    async function handleScrollPreferenceChange(checkbox) {
        const preferEndlessScroll = checkbox.checked;

        try {
            const response = await fetch(`${apiBaseUrl}/auth/preferences`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json'
                },
                credentials: 'include',
                body: JSON.stringify({ preferEndlessScroll })
            });

            if (response.ok) {
                showMessage('Scroll preference updated successfully');
            } else {
                showMessage('Failed to update scroll preference', true);
                // Revert checkbox on error
                checkbox.checked = !preferEndlessScroll;
            }
        } catch (error) {
            console.error('[Profile Settings] Update preference error:', error);
            showMessage('Network error. Please try again.', true);
            // Revert checkbox on error
            checkbox.checked = !preferEndlessScroll;
        }
    }

    function attachEventListeners() {
        // Avatar upload form
        const avatarForm = document.getElementById('avatar-upload-form');
        const fileInput = document.getElementById('avatar-file');
        const deleteBtn = document.getElementById('delete-avatar-btn');

        if (avatarForm && !avatarForm.dataset.initialized) {
            avatarForm.dataset.initialized = 'true';
            if (fileInput) {
                fileInput.addEventListener('change', handleFileChange);
            }
            avatarForm.addEventListener('submit', handleAvatarUploadSubmit);
            if (deleteBtn) {
                deleteBtn.addEventListener('click', handleDeleteClick);
            }
        }

        // Display name form
        const displayNameForms = document.querySelectorAll('form[asp-page-handler="UpdateDisplayName"]');
        displayNameForms.forEach(form => {
            if (!form.dataset.initialized) {
                form.dataset.initialized = 'true';
                form.addEventListener('submit', handleDisplayNameUpdate);
            }
        });

        // Scroll preference checkbox
        const scrollCheckbox = document.querySelector('input[name="preferEndlessScroll"][type="checkbox"]');
        if (scrollCheckbox && !scrollCheckbox.dataset.initialized) {
            scrollCheckbox.dataset.initialized = 'true';
            scrollCheckbox.addEventListener('change', (e) => {
                handleScrollPreferenceChange(e.target);
            });
        }
    }

    // Run on initial page load
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            initProfileSettings().then(() => {
                attachEventListeners();
            });
        });
    } else {
        initProfileSettings().then(() => {
            attachEventListeners();
        });
    }

    // Handle HTMX navigation
    document.body.addEventListener('htmx:load', function(evt) {
        if (document.getElementById('avatar-upload-form')) {
            initProfileSettings().then(() => {
                attachEventListeners();
            });
        }
    });
})();
</script>
